\chapter{Конфигурация сервисов Upstart} \label{cpt:configuration}
Эта глава содержит в себе описания всех инструкций или станс сервисов Upstart. В таблице ниже приводится их список, разбитый на категории.
\begin{table}
\begin{tabular}{|c|c|c|}
\hline Категория & Станса & В какой версии появилась \\ 
\hline \multirow{6}{*}{Работа с процессами} & \stanza{exec} &  \\
 & \stanza{pre--start} & \\
 & \stanza{post--start} & \\
 & \stanza{pre--stop} & \\
 & \stanza{post--stop} & \\
 & \stanza{script} & \\ 
\hline \multirow{3}{*}{Условия на события} & \stanza{manual} & 0.67 \\
 & \stanza{start on} & \\
 & \stanza{stop on} & \\
\hline \multirow{2}{*}{Окружение сервиса} & \stanza{env} & \\
& \stanza{export} & \\
\hline \multirow{4}{*}{Сервисы, задачи и их перезапуск} & \stanza{normal exit} & \\
& \stanza{respawn} & \\
& \stanza{respawn limit} & \\
& \stanza{task} & \\
\hline Работа с экземплярами сервиса & \stanza{instance} & \\
\hline \multirow{5}{*}{Документирование сервиса} & \stanza{author} & \\
& \stanza{description} & \\
& \stanza{emits} & \\
& \stanza{version} & \\
& \stanza{usage} & 1.5 \\
\hline \multirow{14}{*}{Работа с окружением процесса} & \stanza{apparmor load} & 1.9 \\
& \stanza{apparmor switch} & 1.9 \\
& \stanza{console none} & \\
& \stanza{console log} & 1.4 \\
& \stanza{console output} & \\
& \stanza{console owner} & \\
& \stanza{chdir} & \\
& \stanza{limit} & \\
& \stanza{nice} & \\
& \stanza{oom score} & \\
& \stanza{setgid} & 1.4 \\
& \stanza{setuid} & 1.4 \\
& \stanza{umask} & \\
\hline \multirow{6}{*}{Управление процессом} & \stanza{expect fork} & \\
& \stanza{expect daemon} & \\
& \stanza{expect stop} & \\
& \stanza{kill signal} & 1.3 \\
& \stanza{kill timeout} & \\
& \stanza{reload signal} & 1.10 \\
\hline
\end{tabular}  
\end{table}
\newpage
Далее указаны значения станс и приведены примеры кода для каждой из них.
\section{Apparmor} \label{sec:apparmor}
\paragraph{apparmor load} \label{par:apparmor_load} --- загружает указанный профиль доступа AppArmor для данного сервиса в ядро перед тем как запускать этот сервис. Дальнейшее выполнение его главного процесса продолжится уже под управлением загруженного профиля. Синтаксис: \stanza{apparmor load}{<profile-path>}. Пример: \begin{alltt}
\stanza{apparmor load}{\filepath{etc/apparmor.d/usr.sbin.cupsd}}
\stanza{exec}{\filepath{usr/sbin/cupsd -F}}
\end{alltt}

Замечания: \begin{itemize}
\item profile-path должен представлять собой полный путь к профилю AppArmor.
\item Запуск сервиса завершится неудачей если указанного профиля не существует, либо же он не смог загрузиться.
\end{itemize}

\paragraph{apparmor switch} \label{par:apparmor_switch} --- запускает главный процесс сервиса с загруженным профилем AppArmor. Синтаксис: \stanza{apparmor switch}{<profile-name>}, где profile-name --- имя профиля AppArmor. Пример: \begin{alltt}
\stanza{apparmor switch}{\filepath{usr/bin/cupsd}}
\stanza{exec}{\filepath{usr/sbin/cupsd -F}}
\end{alltt}

Замечание: запуск сервиса завершится неудачей если указанного профиля не существует, либо же он еще не загружен.

\section{author} 

Указать автора файла конфигурации, принимает строку заключенную в кавычки. Пример: \begin{alltt}
\stanza{author}{"George Hacker <hackerm@mail.com>"}
\end{alltt}

\section{console}

Для всех версий Upstart младше 1.4 значением по умолчанию для стансы console было console none. В дальнейшем им стало значение console log. Если вы используете версию Upstart 1.4 и выше, то для возврата к предыдущему режиму при его запуске следует указать параметр - -no--log.

\paragraph{console log} --- перенаправляет вывод логов в устройство \filepath{dev/null}. В качестве консолей вывода и ошибок будет указан псевдо--терминал такой, что вывод любого сервиса будет сохраняться в директории \filepath{var/log/upstart/} для системных сервисов и в \$HOME/.cache/upstart/ для пользовательских. Положение директории для логов может быть изменено параметром - -logdir <directory> для Upstart. Если пользовательский сервис выполняется в среде Upstart версии меньше 1.7, то console log трактуется для него как console none.

\paragraph{console none} --- перенаправляет стандартные потоки ввода, вывода и ошибок сервиса в файл \filepath{dev/null}.

\paragraph{console output} --- перенаправляет стандартные потоки ввода, вывода и ошибок сервиса на стандартную консоль. Пример: \begin{alltt}
\stanza{console output}
\stanza{pre-start script}
logger -is -t "\$UPSTART\_JOB" "ERROR: foo!"
exit 1
\stanza{end script}
\stanza{exec sleep 999}
\end{alltt}

\paragraph{console owner} --- аналогично предыдущему за исключением того, что делает сервис владельцем консоли. Это позволяет ему обрабатывать специальные сигналы, наподобие нажатия клавиш <CTRL--C>.

\section{chdir}

Выполняет процесс сервиса в указанной директории directory. Синтаксис: \stanza{chdir}{directory}. Пример: \begin{alltt}
\stanza{chdir}{\filepath{var/mydaemon}}
\end{alltt}

\section{chroot}

Выполняет процесс сервиса внутри chroot--окружения в указанной директории. Синтаксис: \stanza{chroot}{directory}.

Заметим, что указанная директория должна уже содержать в себе все необходимые библиотеки для выполнения процесса, включая командный интерпретатор \filepath{bin/sh}. Пример: \begin{alltt}
\stanza{chroot}{\filepath{srv/chroots/oneiric}}
\end{alltt} 

\section{description}

Задает однострочный комментарий, принимая как аргумент строку в кавычках. Синтаксис \stanza{description}{string}. Пример: \begin{alltt}
\stanza{description}{"My OpenSSH service"}
\end{alltt}

\section{emits}

Описывает множество сигналов, генерируемых данным сервисом. 
~Синтаксис: \stanza{emits}{<values>}.  Эта станса может быть указана для каждого события, порождаемого сервисом. Кроме того, она поддерживает шаблонные символы, распознаваемы командной оболочкой: звездочку, знак вопроса и квадратные скобки. Например, мост upstart--udev--bridge передает большое количество событий от udev. Вместо того, чтобы описывать каждое из них отдельно, можно прибегнуть к следующему синтаксису: \begin{alltt}
\stanza{emits}{*--device--*}
\end{alltt} Еще примеры: \begin{alltt}
\stanza{emits}{foo--event bar--event wibble--event}
\stanza{emits}{hello}
\end{alltt}
\section{end script}

Эта псевдо--станса служит для завершения следующих скриптовых секций: \begin{itemize}
\item script
\item post--start script
\item pre--start script
\item pre--stop script
\item post--stop script
\end{itemize}
\section{env}
Устанавливает переменную окружения и делает ее видимой во всех скриптовых секциях. Синтаксис: \stanza{env}{KEY[=VALUE]}. Пример: \begin{alltt}
\stanza{env}{myvar="hello world"}
\stanza{script}
echo "myvar='\$myvar'" >> \filepath{run/script.log}
\stanza{end script}
\end{alltt}
\section{exec}
Описывает команду запускающую процесс. Команда должна занимать не более одной строки. В ее описании допустимо использовать подстановочные символы воспринимаемые командной оболочкой --- они тоже будут исполнены как и в обычной консольной команде. ~Синтаксис: \stanza{exec}{command [args]}. Пример: \begin{alltt}
\stanza{exec}{\filepath{usr/bin/mydaemon - -option foo -v}}
\end{alltt}
\section{expect}
Следующий раздел является очень важным для понимания функционирования сервисов, порождающих дочерние процессы. С ним рекомендуется ознакомиться \textit{как можно тщательнее}.

Upstart отслеживает PID процессов, принадлежащих сервису. Если определена станса \stanza{instance}, то Upstart будет отслеживать все уникальные PID для данного сервиса.

Если вы не укажете стансу expect, Upstart будет отслеживать \textit{первый} PID сервиса, созданный в результате выполнения инструкций в script или exec. К тому же, большинство сервисов Unix демонизируются, создавая новый процесс, являющийся дочерним по отношению к основному. Так же сервисы часто практикуют <<двойной fork>> чтобы не иметь непосредственной связи с изначальным процессом. В таком случае Upstart должен обязательно иметь возможность отследить все созданные подпроцессы, используйте стансу expect fork или expect daemon, чтобы дать возможность Upstart'у подсчитать количество подпроцессов с помощью pcount.

Для определения конечного PID процесса, который будет использоваться сервисом, необходимо ждать долгое время пока он сделает вызов функции fork. Сам по себе Upstart не может узнать этого после того как будет запущен сервис, поскольку он может породить сколько угодно дочерних процессов, которые могут породить процессы сами. Для того, чтобы дать возможность Upstart отследить <<главный>> PID необходимо использовать стансу expect.

Ее синтаксис прост и вам необязательно дожидаться того времени, когда процесс сервиса вызовет метод fork.

Замечание: \textit{большинство демонов порождают дочерний процесс дважды}.

Если ваша программа не <<демонизируется>> или выполняется <<на переднем плане>>, то очень просто использовать эту стансу и заставить процесс не порождать дочерние процессы. Одна из возможностей состоит в том, чтобы Upstart послал событие вида \event{started JOB=yourjob} как можно раньше до запуска и полной инициализации процесса сервиса. 

И напоследок: станса expect применима \textit{только} к секциям exec и script.

Все это важно понимать в плане использования возможностей, связанных с expect, для двух разных, но дополняющих друг друга задач: \begin{itemize}
\item Отслеживания готовности служб.
\item Отслеживания PID'ов. 
\end{itemize} 