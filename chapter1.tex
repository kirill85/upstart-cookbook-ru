\chapter{Введение в Upstart} \label{sec:Introduction}

\section{Что такое Upstart?}

Цитата с http://upstart.ubuntu.com: "Upstart --- это событийно-ориентированная замена традиционному демону /sbin/init, запускающая задачи и демоны во время загрузки системы и останавливающая их в момент ее выключения, а так же наблюдающая за ними во время работы системы".

Стартовый процесс, он же - система инициализации в Unix и Linux представляет собой процесс с PID равным 1. Можно сказать, что это процесс, который стартует первым с момента запуска системы, исключая запуск ядра и/или initramfs. Как видно из приведенной цитаты, Upstart является заменой традиционному для основанных на архитектуре System V Release 4 систем.

\subsection{Надежность}

Upstart написана с использованием служебной библиотеки NIH ("libnih"). Это очень маленькая, эффективная и безопасная библиотека, содержащая базовые функции. Она разработана для приложений, рано стартующих при загрузке системы. Надежность и безопасность являются абсолютно необходимыми качествами системы инициализации по следующим причинам:
\begin{itemize}
\item она выполняется с правами root.
\item она ответственна за управление важнейшими системными службами.
\item если процесс инициализации обрывается по любой причине, следует паника ядра.
\end{itemize}
Чтобы обеспечить надежность и избежать регрессий, и Upstart и библиотека NIH поставляются с послым набором юнит-тестов. Подробнее смотрите в соответствующей главе.
\subsection{История возникновения}
Upstart был создан из-за неустранимых ограничений существовавших в то время систем инициализаций. Эти системы могут быть отнесены к двум типам: \begin{itemize}
\item Системы инициализации в стиле System V.
\item Системы инициализации основанные на зависимостях.
\end{itemize}
Для лучшего понимания почему Upstart был написан и почему его дизайн был революционным следует рассмотреть эти виды систем инициализаций.
\subsubsection{Upstart и SysV}
\paragraph{Преимущества SysV}
\subparagraph{Простота}
Создание файлов сервисов в системе инициализации SysV является очень простой задачей, так как они представляют собой обычные shell-скрипты. Для включения или исключения демона в заданном уровне запуска достаточно всего лишь создать символическую ссылку на сценарий его выполнения в заданной директории или множестве директорий.
\subparagraph{Гарантированный порядок запуска и остановки демонов}
Это достигается за счет последовательного исполнения скриптов, на которые указывают соответствующие символические ссылки. Относительный порядок, в котором исполняются эти сценарии определяется их именованием: те скрипты, которые стоят в лексикографическом порядке первыми исполняются раньше тех скриптов, которые идут после них.
\paragraph{Ограничения SysV}
\subparagraph{Неоптимальная производительность}
Традиционная система последовательной загрузки и соответствующее ей время запуска сервисов были вполне приемлемы на момент своего изобретения, однако на сегодняшний день она кажется "тормозной" так как не использует никаких особенностей оборудования и не поддерживает параллельность запуска или остановки задач.

SysV init была простой и эффективной для управления системными администраторами.Тем не менее эта модель не до конца использует современные технические возможности, особенно в области распараллеливания запуска демонов.

Наиболее часто встречающийся путь обхода строго последовательного запуска служб состоял в фоновом выполнении своих демонов, что позволяло добиться некоторой степени параллелизма. Повсеместная распространенность этого хака ясно указывала на концептуальный недостаток системы инициализации в стиле SysV.  
\subparagraph{Ориентированность на серверы}
В дни традиционных Unix-систем с их мэйнфреймами и сотнями рабочих терминалов, когда перезагрузки были редки, подход SysV был оправданным. Если аппаратура нуждалась в замене, то главная станция выключалась, аппаратура заменялась и станция включалась вновь. 

Однако с тех пор мир изменился, с точки зрения команды разработчиков Ubuntu нынешние пользователи могут захотеть перезагрузить свою рабочую систему когда угодно. \footnote{Не забываем также о появлении большого количества "живых" систем, где сеансы работы носят эпизодический характер. --- прим. переводчика.}
\subparagraph{Состав оборудования предполагается неизменным}\footnote{На время сеанса работы с системой --- прим. переводчика}
Современные Linux -- системы часто имеют дело с оборудованием, поддерживающим "горячие" замены и должны адекватно отражать подобные вещи в своей работе. Традиционный подход, основанный на статических скриптах инициализации, не предоставляет такой возможности.
\subparagraph{Каждый сценарий делает ненужную работу} 
Большинство скриптов инициализации являются шаблонными. Например, они выполняют такие первоначальные проверки как \begin{itemize}
\item Единственность экземпляра запущенного демона.
\item Проверять существование директории или файла.
\item Удалять устаревшие кэш -- файлы.
\item Отслеживать зависимости демонов при их выполнении.
\item Перезапускать главный процесс своего демона.
\end{itemize}
Наиболее трудоемкой и дорогостоящей по времени операцией является обработка вызовов зависимых демонов. LSB дает обще утилиты, которые могут выполнять эти операции, но не нужно возлагать выполнение большого числа однотипных операций на каждый сервис: их должна выполнять сама система инициализации.
\subsubsection{Критика систем, ориентированных на зависимости}
\paragraph{Достоинства систем ориентированных на зависимости}
\subparagraph{Учет зависимостей одних служб от других}
Признание, что демону нужно использовать зависимые от него самого демоны, является большим шагом вперед по сравнению с традиционной SysV -- системой. Это перекладывает большую часть рутинных действий на саму систему инициализации и снижает сложность отдельно взятого скрипта инициализации.
\paragraph{Недостатки}
\subparagraph{Не отражает "живую натуру" современного Linux}
Главная проблема состоит в том, что в таких случаях по-прежнему не признается динамичный характер современных Linux -- систем.

К примеру, если такой СИ \footnote{системе инициализации --- прим. переводчика} необходимо запустить сервис базы данных MySQL, то она сначала запустит те сервисы, от которых зависит сервис MySQL. В данном случае это совершенно правильное решение.

С другой стороны допустим, что пользователь захотел подключить к своему ноутбуку внешний монитор. Хотелось бы чтобы система в этом случае выдавала некий диалог с вопросом как ей поступить с этим внешним монитором. Такое здесь возможно только при наличии СИ "с хаками", так как стандартная СИ с учетом зависимостей никак не может узнать об изменении конфигурации оборудования. В случае с диалогом подключения монитора у вас могут быть следующие варианты: \begin{itemize}
\item Ничего не делать.
\item Иметь демона, опрашивающего систему на предмет появления новых устройств.
\end{itemize} 
В действительности лучшим выбором будет такая система, которая будет принимать и обрабатывать асинхронные сообщения о событиях и запускать подходящие сервисы при необходимости.

Резюмируя вышеизложенное приходим к следующим тезисам: \begin{itemize}
\item Upstart запускает службы когда необходимые для этого условия будут выполнены: в файле конфигурации службы необходимо только указать условия ее запуска и ее исполняемый файл.
\item СИ с учетом зависимостей сперва удовлетворяют зависимости запускаемой службы перед ее запуском: каждый раз служба с помощью грубой силы запускает все свои зависимости, прежде чем запуститься сама.

Заметьте, что при этом вся тяжелая работа по-прежнему ложится на сами службы.
\end{itemize}
Эти выводы должны заставить вас задуматься о незаметном, но важном различии этих типов служб.

Другая проблема с СИ на основе зависимостей состоит в том, что они должны иметь в своем составе подсистему -- решатель зависимостей, которая может оказаться сложной и неэффективной.
\subsection{Дизайн Upstart: почему это революционный подход}
Необходимо заметить ограничения вышеперечисленных подходов к управлению службами, чтобы понять почему Upstart особенный.

Подход Upstart революционен, так как в нем признается динамический характер современных компьютерных систем, он также был разработан с учетом этого динамизма. Так же Upstart работает с асинхронными событиями, что тоже является прогрессивным по сравнению с теми двумя альтернативными способами.

Upstart посылает события и каждый сервис может принять и обработать нужное ему. Когда отправляется некоторое множество событий, удовлетворяющих условиям запуска или остановки какой-нибудь службы, то Upstart ее запускает либо же останавливает. Если несколько служб реагирует на одинаковые события, то они будут запущены или остановлены параллельно. Поясним: Upstart запускает все зависимые службы самостоятельно, а не по запросу какой-либо из них - в этом состоит его отличие от СИ основанных на зависимостях.

Кроме того, Upstart принимает во внимание верховного судью, ответственного за управление устройствами: ядро.

В сущности, Upstart является инициатором событий: он испускает события, обработчики которых управляют теми или иными демонами или службами. Как программа, созданная в духе Unix-way, он делает эту работу очень хорошо. Он эффективен, быстр, гибок и надежен. Это обеспечивается вспомогательными демонами (вроде upstart-udev-bridge или upstart-socket-bridge) для внедрения новых типов событий в систему и реакций на них. Этот дизайн очень разумный и понятный, так как система инициализации должна быть устойчивой к отказам и не допускать паники ядра вследствие этого. Таким образом, любая функциональность, которая не считается критичной, отдана "на откуп" другим демонам.
\section{Производительность}
Upstart была спроектирована с учетом требований к производительности.Она активно использует функции из библиотеки NIH, которая оптимизирована для эффективного исполнения на начальном этапе загрузки системы. 
\section{Серверный аспект} 
Upstart используется как Ubuntu Desktop, так и в Ubuntu Server, а следовательно и в Ubuntu Cloud. Почему Upstart также полезен в серверной среде?
\subsection{Ускорение загрузки}
Существует точка зрения, что для сервера время загрузки не играет существенной роли так как все упирается во время инициализации оборудования, например, RAID-массивов. Тем не менее, никто не хочет чтобы система стартовала дольше, чем это возможно.

Рассмотрим также случай развертывания облачных сервисов.Здесь скорость загрузки очень важна так как это влияет на время, необходимое на скорость развертывания нового экземпляра облака. Чем быстрее вы сможете развернуть облачные сервисы для обработки больших объемов данных, тем лучше вы сможете обслужить своих клиентов.
\subsection{Аварийные режимы}
Ни для кого не секрет, что компьютерные системы становятся все более сложными. В прежние времена Unix все режимы работы системы могли быть задокументированы и учтены в различных "уровнях выполнения". В настоящее время мы ожидаем, что система будет самостоятельно реагировать на возникающие проблемы и даже самовосстанавливаться в простых случаях.

Обстановка поменялась и Upstart полностью в состоянии принять такие изменения, благодаря своему дизайну. Важно отметить, что Upstart не привязан жестко к "уровням выполнения", он не имеет понятия об их внутреннем устройстве, но он поддерживает и эту модель наравне с событийной. А поскольку события являются абстракциями, то их можно использовать при построении более высокоуровневых решений. Добавим также, что поскольку события являются динамическими, то Upstart с их помощью может быть настроен на множество сценариев работы системы, в том числе и при ее отказах.