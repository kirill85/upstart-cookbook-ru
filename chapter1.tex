\chapter{Введение в Upstart} \label{sec:Introduction}

\section{Что такое Upstart?}

Цитата с http://upstart.ubuntu.com: "Upstart --- это событийно-ориентированная замена традиционному демону /sbin/init, запускающая задачи и демоны во время загрузки системы и останавливающая их в момент ее выключения, а так же наблюдающая за ними во время работы системы".

Стартовый процесс, он же - система инициализации в Unix и Linux представляет собой процесс с PID равным 1. Можно сказать, что это процесс, который стартует первым с момента запуска системы, исключая запуск ядра и/или initramfs. Как видно из приведенной цитаты, Upstart является заменой традиционному для основанных на архитектуре System V Release 4 систем.

\subsection{Надежность}

Upstart написана с использованием служебной библиотеки NIH ("libnih"). Это очень маленькая, эффективная и безопасная библиотека, содержащая базовые функции. Она разработана для приложений, рано стартующих при загрузке системы. Надежность и безопасность являются абсолютно необходимыми качествами системы инициализации по следующим причинам:
\begin{itemize}
\item она выполняется с правами root.
\item она ответственна за управление важнейшими системными службами.
\item если процесс инициализации обрывается по любой причине, следует паника ядра.
\end{itemize}
Чтобы обеспечить надежность и избежать регрессий, и Upstart и библиотека NIH поставляются с послым набором юнит-тестов. Подробнее смотрите в соответствующей главе.
\subsection{История возникновения}
Upstart был создан из-за неустранимых ограничений существовавших в то время систем инициализаций. Эти системы могут быть отнесены к двум типам: \begin{itemize}
\item Системы инициализации в стиле System V.
\item Системы инициализации основанные на зависимостях.
\end{itemize}
Для лучшего понимания почему Upstart был написан и почему его дизайн был революционным следует рассмотреть эти виды систем инициализаций.
\subsubsection{Upstart и SysV}
\paragraph{Преимущества SysV}
\subparagraph{Простота}
Создание файлов сервисов в системе инициализации SysV является очень простой задачей, так как они представляют собой обычные shell-скрипты. Для включения или исключения демона в заданном уровне запуска достаточно всего лишь создать символическую ссылку на сценарий его выполнения в заданной директории или множестве директорий.
\subparagraph{Гарантированный порядок запуска и остановки демонов}
Это достигается за счет последовательного исполнения скриптов, на которые указывают соответствующие символические ссылки. Относительный порядок, в котором исполняются эти сценарии определяется их именованием: те скрипты, которые стоят в лексикографическом порядке первыми исполняются раньше тех скриптов, которые идут после них.
\paragraph{Ограничения SysV}
\subparagraph{Неоптимальная производительность}
Традиционная система последовательной загрузки и соответствующее ей время запуска сервисов были вполне приемлемы на момент своего изобретения, однако на сегодняшний день она кажется "тормозной" так как не использует никаких особенностей оборудования и не поддерживает параллельность запуска или остановки задач.

SysV init была простой и эффективной для управления системными администраторами.Тем не менее эта модель не до конца использует современные технические возможности, особенно в области распараллеливания запуска демонов.

Наиболее часто встречающийся путь обхода строго последовательного запуска служб состоял в фоновом выполнении своих демонов, что позволяло добиться некоторой степени параллелизма. Повсеместная распространенность этого хака ясно указывала на концептуальный недостаток системы инициализации в стиле SysV.  
\subparagraph{Ориентированность на серверы}
В дни традиционных Unix-систем с их мэйнфреймами и сотнями рабочих терминалов, когда перезагрузки были редки, подход SysV был оправданным. Если аппаратура нуждалась в замене, то главная станция выключалась, аппаратура заменялась и станция включалась вновь. 

Однако с тех пор мир изменился, с точки зрения команды разработчиков Ubuntu нынешние пользователи могут захотеть перезагрузить свою рабочую систему когда угодно. \footnote{Не забываем также о появлении большого количества "живых" систем, где сеансы работы носят эпизодический характер. --- прим. переводчика.}
\subparagraph{Состав оборудования предполагается неизменным}\footnote{На время сеанса работы с системой --- прим. переводчика}
Современные Linux -- системы часто имеют дело с оборудованием, поддерживающим "горячие" замены и должны адекватно отражать подобные вещи в своей работе. Традиционный подход, основанный на статических скриптах инициализации, не предоставляет такой возможности.
\subparagraph{Каждый сценарий делает ненужную работу} 
Большинство скриптов инициализации являются шаблонными. Например, они выполняют такие первоначальные проверки как \begin{itemize}
\item Единственность экземпляра запущенного демона.
\item Проверять существование директории или файла.
\item Удалять устаревшие кэш -- файлы.
\item Отслеживать зависимости демонов при их выполнении.
\item Перезапускать главный процесс своего демона.
\end{itemize}
Наиболее трудоемкой и дорогостоящей по времени операцией является обработка вызовов зависимых демонов. LSB дает обще утилиты, которые могут выполнять эти операции, но не нужно возлагать выполнение большого числа однотипных операций на каждый сервис: их должна выполнять сама система инициализации.
\subsubsection{Критика систем, ориентированных на зависимости}
\paragraph{Достоинства систем ориентированных на зависимости}
\subparagraph{Учет зависимостей одних служб от других}
Признание, что демону нужно использовать зависимые от него самого демоны, является большим шагом вперед по сравнению с традиционной SysV -- системой. Это перекладывает большую часть рутинных действий на саму систему инициализации и снижает сложность отдельно взятого скрипта инициализации.
\paragraph{Недостатки}
\subparagraph{Не отражает "живую натуру" современного Linux}
Главная проблема состоит в том, что в таких случаях по-прежнему не признается динамичный характер современных Linux -- систем.

К примеру, если такой СИ \footnote{системе инициализации --- прим. переводчика} необходимо запустить сервис базы данных MySQL, то она сначала запустит те сервисы, от которых зависит сервис MySQL. В данном случае это совершенно правильное решение.

С другой стороны допустим, что пользователь захотел подключить к своему ноутбуку внешний монитор. Хотелось бы чтобы система в этом случае выдавала некий диалог с вопросом как ей поступить с этим внешним монитором. Такое здесь возможно только при наличии СИ "с хаками", так как стандартная СИ с учетом зависимостей никак не может узнать об изменении конфигурации оборудования. В случае с диалогом подключения монитора у вас могут быть следующие варианты: \begin{itemize}
\item Ничего не делать.
\item Иметь демона, опрашивающего систему на предмет появления новых устройств.
\end{itemize} 
В действительности лучшим выбором будет такая система, которая будет принимать и обрабатывать асинхронные сообщения о событиях и запускать подходящие сервисы при необходимости.

Резюмируя вышеизложенное приходим к следующим тезисам: \begin{itemize}
\item Upstart запускает службы когда необходимые для этого условия будут выполнены: в файле конфигурации службы необходимо только указать условия ее запуска и ее исполняемый файл.
\item СИ с учетом зависимостей сперва удовлетворяют зависимости запускаемой службы перед ее запуском: каждый раз служба с помощью грубой силы запускает все свои зависимости, прежде чем запуститься сама.

Заметьте, что при этом вся тяжелая работа по-прежнему ложится на сами службы.
\end{itemize}
Эти выводы должны заставить вас задуматься о незаметном, но важном различии этих типов служб.

Другая проблема с СИ на основе зависимостей состоит в том, что они должны иметь в своем составе подсистему -- решатель зависимостей, которая может оказаться сложной и неэффективной.
\subsection{Дизайн Upstart: почему это революционный подход}
Необходимо заметить ограничения вышеперечисленных подходов к управлению службами, чтобы понять почему Upstart особенный.

Подход Upstart революционен, так как в нем признается динамический характер современных компьютерных систем, он также был разработан с учетом этого динамизма. Так же Upstart работает с асинхронными событиями, что тоже является прогрессивным по сравнению с теми двумя альтернативными способами.

Upstart посылает события и каждый сервис может принять и обработать нужное ему. Когда отправляется некоторое множество событий, удовлетворяющих условиям запуска или остановки какой-нибудь службы, то Upstart ее запускает либо же останавливает. Если несколько служб реагирует на одинаковые события, то они будут запущены или остановлены параллельно. Поясним: Upstart запускает все зависимые службы самостоятельно, а не по запросу какой-либо из них - в этом состоит его отличие от СИ основанных на зависимостях.