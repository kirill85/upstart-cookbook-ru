\chapter{Понятия и терминология}
Главными понятиями у Upstart являются события и задания ("jobs"). Важно понимать различия между ними.
\section{Задания}
"Единицей работы" в Upstart является задача ("task") или служба ("service"). Задание, в не зависимости от его типа, описывается в файле конфигурации задания.
\subsection{Виды заданий}
\paragraph{Разовое задание ("task")}

Разовое задание представляет собой короткоживущий процесс, то есть имеющий конечное время на выполнение и безусловно завершающийся.

Например, удаление некоторого файла представляет собой такое задание: есть старт программы, сама операция его удаления --- возможно занимающая время, если файл большой --- и завершение задачи по окончании удаления файла.

В дальнейшем такие демоны будут именоваться задачами ("task job").

\paragraph{Сервис ("service job")}

Сервис или демон представляет собой долгоживущий процесс --- возможно, вплоть до останова системы. 
В противоположность заданию, сервис никогда не завершает свою работу сам.

Примерами сервисов могут служить базы данных, веб-серверы и тому подобное.
\paragraph{Абстрактный сервис}

Это еще один тип сервиса, отличающийся от первых двух тем, что в его файле конфигурации 
отсутствует ключевое слово exec или секция script. Каждый такой сервис может быть запущен или остановлен, но он не порождает дочернего процесса (PID). Фактически такие сервисы "выполняются" до тех пор пока явно не останавливаются администратором системы. Абстрактные сервисы существуют в Upstart  только по причине их чрезвычайной полезности. Например такие сервисы могут служить цели синхронизации.
\subsection{Состояния сервисов}

В таблице ниже приводятся возможные состояния, в которых могут находиться сервисы и допустимые переходы между ними.
\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline Текущее состояние &  Команда  \\ 
\hline  & start & stop \\ 
\hline waiting & starting & не определено \\ 
\hline starting & pre-start & stopping \\ 
\hline pre-start & spawned & stopping \\ 
\hline spawned & post-start & stopping \\ 
\hline post-start & running & stopping \\
\hline running & stopping & pre-stop или stopping \footnote{} \\
\hline pre-stop & running & stopping \\
\hline stopping & killed & killed \\
\hline killed & post-stop & post-stop \\
\hline post-stop & starting & waiting \\
\hline
\end{tabular} 
\end{table}
Например, если сервис находится в состоянии starting (стартует) и ему была отдана команда start, то он перейдет в состояние pre-start (приготовиться к запуску).

Заметьте, что эти переходы могут быть сделаны так быстро, что вы не успеете заметить этого в выводе утилиты initctl. Изменить эту ситуацию можно командой initctl log-priority с параметром равным info
или debug.

Пояснения к обозначениям состояний: \begin{itemize}
\item waiting --- начальное состояние.
\item starting --- сервис начинает запускаться.
\item pre-start --- выполняется секция pre-start в файле конфигурации сервиса.
\item spawned --- исполняется инструкция exec или секция script.
\item post-start --- исполняются инструкции в секции post-start файла конфигурации.
\item running --- состояние, следующее за post-start, означающее, что сервис исполняется (при этом ему необязательно соответствует PID).
\item pre-stop --- выполняется секция pre-stop.
\item stopping --- следует за pre-stop. 
\item killed --- сервис начинает завершаться.
\item post-stop --- завершающие действия по очистке окружения и возврату ресурсов.
\end{itemize}

Подробно увидеть переходы между состояниями сервиса можно увидеть одним из трех способов: \begin{enumerate}
\item Выставлением параметра log-priority в значение debug.
\item С помощью утилиты tail с аргументами -f <service.log>
\item Командами start/restart/stop или отправкой соответствующих событий.
\end{enumerate}
\section{Окружение сервиса}
Пока Upstart исполняет сервис, он предоставляет ему очень ограниченное системное окружение, 
содержащее две основные переменные: TERM и PATH. Сам Upstart также устанавливает специальные переменные, которые может использовать процесс. Подробнее об этом будет изложено ниже. Если ваши системные сервисы 
требуют введения специальных переменных, то вы можете использовать для этого ключевые слова env и export.

Сервисы для сессий устроены по-другому: для них также доступно определение переменных с помощью env и export, но они также наследуют переменные окружения из своей сессии.
\section{Файл конфигурации сервиса}
Сервис определяется в файлах конфигурации сервиса, или проще говоря в .conf файле. Он представляет собой простой текстовый файл, содержащий одну или более стансу, или ключевую инструкцию, Файлы конфигурации именуются по правилу <name>.conf, где  name --- имя приложения или сервиса. .conf файлы бывают двух типов: 
системные и пользовательские. В дальнейшем под словом "сервис" будет пониматься его файл конфигурации.

Файлы системных сервисов по умолчанию располагаются в директории /etc/init. Однако это умолчание можно изменить с помощью параметра --confdir=<dir> для демона /sbin/init. 

Upstart 1.3 ввел понятие пользовательских сервисов, выполняющихся от имени непривилегированного пользователя. По умолчанию файлы конфигурации таких сервисов располагаются в директории \textdollar HOME/.init/. Сейчас эта возможность более недоступна, начиная с версии Ubuntu 11.10 и выше.
Синтаксис таких файлов полностью одинаков синтаксису файлов системных сервисов.\footnote{Недопустимо, однако, совпадение имен пользовательского и системного сервиса.}

Начиная с версии Upstart 1.7, были введены сервисы в рамках сессии, во всем подобные пользовательским сервисам за исключением того, что они выполняются с PID унаследованным от текущей сессии, а не 1 как
раньше. 
Файлы их конфигурации могут располагаться в следующих директориях: \begin{itemize}
\item \textdollar XDG\_CONFIG\_HOME/upstart/ (или \textdollar HOME/.config/upstart).
\item \textdollar HOME/.init/.
\item \textdollar XDG\_CONFIG\_DIRS.
\item /usr/share/upstart/sessions.
\end{itemize}
Имя каждого задания принимается базовому имени его файла конфигурации за вычетом имен всех вышележащих директорий. Например, если файл конфигурации расположен в \textdollar HOME/.config/upstart/hello/world.conf, то имя сервиса будет "hello/world".

Upstart разрешает конфликты имен, просто "подхватывая" первый корректный файл конфигурации. Например, пусть есть два файла: \textdollar HOME/.init/foo.conf и \textdollar HOME/.config/upstart/foo.conf, 
в этом случае будет использоваться первый из них. Пусть теперь существуют файлы \textdollar HOME/.init/foo.conf, \textdollar HOME/.config/upstart/foo.conf и \textdollar HOME/.config/upstart/foo.conf.override. Тогда будет взят за основу первый из файлов и к нему будут применены определения из файла .override.
\subsection{Несимметричные сервисы}
Так называются сервисы, в файлах конфигурации которых отсутствует одна из директив start on или stop on, либо обе вместе. В случае отсутствия start on сервис самостоятельно не запустится и запускать его должен системный администратор командой initctl start. Аналогично, в случае отсутствия stop on, для сервиса не существует события остановки его надо останавливать вручную командой initctl stop. В третьем случае ответственность за запуск и останов сервиса целиком лежит на администраторе системы.
\subsection{Простейший файл конфигурации сервиса}
Чтобы считаться правильно написанным, файл конфигурации должен обладать следующими признаками: \begin{itemize}
\item Не быть пустым.
\item Не иметь синтаксических ошибок.
\item Содержать одну или больше директив.
\end{itemize}
Приведем примеры простейших файлов конфигураций. 
\begin{itemize}
\item \stanza{\# Это файл мета-задания, содержащий только комментарий}
\item Здесь содержится директива author. \stanza{author} {"John Smith"}  
\item А здесь - директива description: \stanza{description}{"My service"} 
\end{itemize}
\section{События}
Upstart посылает уведомления всем слушающим его сервисам. События можно подразделить на сигналы, методы или ловушки в зависимости от того, как они посылаются или принимаются. Заметим, что невозможно остановить какой-либо сервис или событие так, чтобы заметить момент начала генерации этого события.

Если не найдется сервиса, который реагирует на события директивами start on или stop on, то событие не обрабатывается никоим образом.

Любое событие может быть создано администратором с помощью команды initctl emit <event>. Заметим, что некоторые события являются специальными, для ознакомления с ними обращайтесь к разделу справки по upstart--events. Заметим также, что допустимо именовать события так же, как и сервисы.

Сервисы могут запускаться и останавливаться в ответ на запуск и остановку других сервисов. Upstart предусматривает набор событий, которые рассылаются, чтобы уведомить сервисы о переходах из одного состояния в другое. Важно понимать, что эти сигналы и состояния сервиса --- не одно и то же.

Эти события наступают в следующих случаях: \begin{itemize}
\item starting --- посылается если сервис готовится стартовать.
\item started --- отправляется если сервис исполняется. При этом он не обязан иметь исполняемый файл или скрипт,  т.е. может быть абстрактным.
\item stopping --- отправляется если сервис готовится останавливаться.
\item stopped --- отправляется если сервис завершился, так или иначе. 
\end{itemize}
См. жизненный цикл процесса %\ref{sec:lifecycle}
Рассмотрим процесс запуска самого Upstart: \begin{enumerate}
\item Он производит внутренние инициализации.
\item Далее отправляется единственное сообщение \event{startup}. Это сигнальное сообщение, оповещающее систему о запуске. Заметьте, что это \textit{не сервис} startup.
\item Утилита init запускает сервис mountall, поскольку событие startup удовлетворяет условию его запуска \stanza{start on}{\event{startup}}.
\item Сервис mountall рассылает события далее, включая события \event{local-filesystems} и \event{all-swaps}. 
\end{enumerate}
Upstart предоставляет три вида событий: сигналы, методы и ловушки.
\subsection*{Сигналы}
Сигналы представляют собой асинхронно обрабатываемые события. Управление возвращается к пославшему сигнал немедленно по завершении его испускания. Иначе говоря, сервис, испустивший сигнал, не ждет на него ответа, 
а сам сигнал является чисто информационным. Сигналы можно генерировать используя опцию \\- -no--wait утилиты initctl: \begin{verbatim}
initctl emit --no-wait <signal>
\end{verbatim} Неблокирующее поведение непосредственно влияет на доступность отправителя к дальнейшему взаимодействию без ожидания событий от других сервисов. Сервисы которые используют реакцию на события через директивы start on и stop on никак не могут приостановить работу сервисов, испускающих эти события.
\subsection*{Методы}
Методы представляют собой блокирующие или синхронные события, которые как правило используются совместно с заданиями (\textit{task}). Они работают подобно методам в языках программирования: вызывающий шлет событие 
и затем ждет реакцию на него в виде ответного события или кода завершения (успешного или нет).

Послать метод очень просто: \begin{verbatim}
initctl emit MyMethod
\end{verbatim} Это похоже на посылку сигнала за исключением того, что в данном случае событие обрабатывается синхронным образом, то есть пославший событие ждет, пока initctl завершит его обработку. По завершении работы initctl для задачи, которой был послан метод MyMethod. есть два способа выполнить работу: завершить ее успешно или вернуть код ошибки в систему. Минимальный файл конфигурации задачи, рассчитанной на запуск по приходу события MyMethod выглядит следующим образом: \\
\stanza{start on}{MyMethod} \\
\stanza{task} \\
\stanza{exec} \/usr/bin/myapp \$ACTION \\

Вы можете запустить задачу <jobname> и проверить результат ее выполнения следующей командой: \begin{verbatim}
initctl emit MyMethod ACTION=do_something
[ $? -ne 0 ] && { echo "ERROR: myapp failed"; exit 1; }
\end{verbatim} 
\subsection*{<<Ловушки>> (hooks)}
Событие-ловушка является синхронным. Иначе говоря, ловушка является чем-то средним между сигналом и методом: подобно сигналу она представляет собой уведомление об изменениях в системе, однако пославший <<ловушку>> ждет окончания ее обработки перед тем как отправить что-то ещё. <<Ловушки>> используются в качестве <<флагов>> для всех слушающих их сервисов. Примеры <<ловушек>> можно найти в справочных руководствах по событиям \event{starting} и \event{stopping}.   