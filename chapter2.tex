\chapter{Понятия и терминология}
Главными понятиями у Upstart являются события и задания ("jobs"). Важно понимать различия между ними.
\section{Задания}
"Единицей работы" в Upstart является задача ("task") или служба ("service"). Задание, в не зависимости от его типа, описывается в файле конфигурации задания.
\subsection{Виды заданий}
\paragraph{Разовое задание ("task")}

Разовое задание представляет собой короткоживущий процесс, то есть имеющий конечное время на выполнение и безусловно завершающийся.

Например, удаление некоторого файла представляет собой такое задание: есть старт программы, сама операция его удаления --- возможно занимающая время, если файл большой --- и завершение задачи по окончании удаления файла.

В дальнейшем такие демоны будут именоваться задачами ("task job").

\paragraph{Сервис ("service job")}

Сервис или демон представляет собой долгоживущий процесс --- возможно, вплоть до останова системы. 
В противоположность заданию, сервис никогда не завершает свою работу сам.

Примерами сервисов могут служить базы данных, веб-серверы и тому подобное.
\paragraph{Абстрактный сервис}

Это еще один тип сервиса, отличающийся от первых двух тем, что в его файле конфигурации 
отсутствует ключевое слово exec или секция script. Каждый такой сервис может быть запущен или остановлен, но он не порождает дочернего процесса (PID). Фактически такие сервисы "выполняются" до тех пор пока явно не останавливаются администратором системы. Абстрактные сервисы существуют в Upstart  только по причине их чрезвычайной полезности. Например такие сервисы могут служить цели синхронизации.
\subsection{Состояния сервисов}

В таблице ниже приводятся возможные состояния, в которых могут находиться сервисы и допустимые переходы между ними.
\begin{table}[h]
\begin{tabular}{|l|l|l|}
\hline Текущее состояние &  Команда  \\ 
\hline  & start & stop \\ 
\hline waiting & starting & не определено \\ 
\hline starting & pre-start & stopping \\ 
\hline pre-start & spawned & stopping \\ 
\hline spawned & post-start & stopping \\ 
\hline post-start & running & stopping \\
\hline running & stopping & pre-stop или stopping \footnote{} \\
\hline pre-stop & running & stopping \\
\hline stopping & killed & killed \\
\hline killed & post-stop & post-stop \\
\hline post-stop & starting & waiting \\
\hline
\end{tabular} 
\end{table}
Например, если сервис находится в состоянии starting (стартует) и ему была отдана команда start, то он перейдет в состояние pre-start (приготовиться к запуску).

Заметьте, что эти переходы могут быть сделаны так быстро, что вы не успеете заметить этого в выводе утилиты initctl. Изменить эту ситуацию можно командой initctl log-priority с параметром равным info
или debug.

Пояснения к обозначениям состояний: \begin{itemize}
\item waiting --- начальное состояние.
\item starting --- сервис начинает запускаться.
\item pre-start --- выполняется секция pre-start в файле конфигурации сервиса.
\item spawned --- исполняется инструкция exec или секция script.
\item post-start --- исполняются инструкции в секции post-start файла конфигурации.
\item running --- состояние, следующее за post-start, означающее, что сервис исполняется (при этом ему необязательно соответствует PID).
\item pre-stop --- выполняется секция pre-stop.
\item stopping --- следует за pre-stop. 
\item killed --- сервис начинает завершаться.
\item post-stop --- завершающие действия по очистке окружения и возврату ресурсов.
\end{itemize}

Подробно увидеть переходы между состояниями сервиса можно увидеть одним из трех способов: \begin{enumerate}
\item Выставлением параметра log-priority в значение debug.
\item С помощью утилиты tail с аргументами -f <service.log>
\item Командами start/restart/stop или отправкой соответствующих событий.
\end{enumerate}
\section{Окружение сервиса}
Пока Upstart исполняет сервис, он предоставляет ему очень ограниченное системное окружение, 
содержащее две основные переменные: TERM и PATH. Сам Upstart также устанавливает специальные переменные, которые может использовать процесс. Подробнее об этом будет изложено ниже. Если ваши системные сервисы 
требуют введения специальных переменных, то вы можете использовать для этого ключевые слова env и export.

Сервисы для сессий устроены по-другому: для них также доступно определение переменных с помощью env и export, но они также наследуют переменные окружения из своей сессии.
\section{Файл конфигурации сервиса}
Сервис определяется в файлах конфигурации сервиса, или проще говоря в .conf файле. Он представляет собой простой текстовый файл, содержащий одну или более стансу, или ключевую инструкцию, Файлы конфигурации именуются по правилу <name>.conf, где  name --- имя приложения или сервиса. .conf файлы бывают двух типов: 
системные и пользовательские. В дальнейшем под словом "сервис" будет пониматься его файл конфигурации.

Файлы системных сервисов по умолчанию располагаются в директории /etc/init. Однако это умолчание можно изменить с помощью параметра --confdir=<dir> для демона /sbin/init. 

Upstart 1.3 ввел понятие пользовательских сервисов, выполняющихся от имени непривилегированного пользователя. По умолчанию файлы конфигурации таких сервисов располагаются в директории \textdollar HOME/.init/. Сейчас эта возможность более недоступна, начиная с версии Ubuntu 11.10 и выше.
Синтаксис таких файлов полностью одинаков синтаксису файлов системных сервисов.\footnote{Недопустимо, однако, совпадение имен пользовательского и системного сервиса.}

Начиная с версии Upstart 1.7, были введены сервисы в рамках сессии, во всем подобные пользовательским сервисам за исключением того, что они выполняются с PID унаследованным от текущей сессии, а не 1 как
раньше. 
Файлы их конфигурации могут располагаться в следующих директориях: \begin{itemize}
\item \textdollar XDG\_CONFIG\_HOME/upstart/ (или \textdollar HOME/.config/upstart).
\item \textdollar HOME/.init/.
\item \textdollar XDG\_CONFIG\_DIRS.
\item /usr/share/upstart/sessions.
\end{itemize}
Имя каждого задания принимается базовому имени его файла конфигурации за вычетом имен всех вышележащих директорий. Например, если файл конфигурации расположен в \textdollar HOME/.config/upstart/hello/world.conf, то имя сервиса будет "hello/world".

Upstart разрешает конфликты имен, просто "подхватывая" первый корректный файл конфигурации. Например, пусть есть два файла: \textdollar HOME/.init/foo.conf и \textdollar HOME/.config/upstart/foo.conf, 
в этом случае будет использоваться первый из них. Пусть теперь существуют файлы \textdollar HOME/.init/foo.conf, \textdollar HOME/.config/upstart/foo.conf и \textdollar HOME/.config/upstart/foo.conf.override. Тогда будет взят за основу первый из файлов и к нему будут применены определения из файла .override.
\subsection{Несимметричные сервисы}
Так называются сервисы, в файлах конфигурации которых отсутствует одна из директив start on или stop on, либо обе вместе. В случае отсутствия start on сервис самостоятельно не запустится и запускать его должен системный администратор командой initctl start. Аналогично, в случае отсутствия stop on, для сервиса не существует события остановки его надо останавливать вручную командой initctl stop. В третьем случае ответственность за запуск и останов сервиса целиком лежит на администраторе системы.
\subsection{Простейший файл конфигурации сервиса}
Чтобы считаться правильно написанным, файл конфигурации должен обладать следующими признаками: \begin{itemize}
\item Не быть пустым.
\item Не иметь синтаксических ошибок.
\item Содержать одну или больше директив.
\end{itemize}
Приведем примеры простейших файлов конфигураций. 
\begin{itemize}
\item \stanza{\# Это файл мета-задания, содержащий только комментарий}.
\item Здесь содержится директива author. \stanza{author} {"John Smith"}  
\item А здесь - директива description: \stanza{description}{"My service"} 
\end{itemize}
\section{События}
Upstart посылает уведомления всем слушающим его сервисам. События можно подразделить на сигналы, методы или ловушки в зависимости от того, как они посылаются или принимаются. Заметим, что невозможно остановить какой-либо сервис или событие так, чтобы заметить момент начала генерации этого события.

Если не найдется сервиса, который реагирует на события директивами start on или stop on, то событие не обрабатывается никоим образом.

Любое событие может быть создано администратором с помощью команды initctl emit <event>. Заметим, что некоторые события являются специальными, для ознакомления с ними обращайтесь к разделу справки по upstart--events. Заметим также, что допустимо именовать события так же, как и сервисы.

Сервисы могут запускаться и останавливаться в ответ на запуск и остановку других сервисов. Upstart предусматривает набор событий, которые рассылаются, чтобы уведомить сервисы о переходах из одного состояния в другое. Важно понимать, что эти сигналы и состояния сервиса --- не одно и то же.

Эти события наступают в следующих случаях: \begin{itemize}
\item starting --- посылается если сервис готовится стартовать.
\item started --- отправляется если сервис исполняется. При этом он не обязан иметь исполняемый файл или скрипт,  т.е. может быть абстрактным.
\item stopping --- отправляется если сервис готовится останавливаться.
\item stopped --- отправляется если сервис завершился, так или иначе. 
\end{itemize}
См. жизненный цикл процесса %\ref{sec:lifecycle}
Рассмотрим процесс запуска самого Upstart: \begin{enumerate}
\item Он производит внутренние инициализации.
\item Далее отправляется единственное сообщение \event{startup}. Это сигнальное сообщение, оповещающее систему о запуске. Заметьте, что это \textit{не сервис} startup.
\item Утилита init запускает сервис mountall, поскольку событие startup удовлетворяет условию его запуска \stanza{start on}{\event{startup}}.
\item Сервис mountall рассылает события далее, включая события \event{local-filesystems} и \event{all-swaps}. 
\end{enumerate}
Upstart предоставляет три вида событий: сигналы, методы и ловушки.
\subsection*{Сигналы}
Сигналы представляют собой асинхронно обрабатываемые события. Управление возвращается к пославшему сигнал немедленно по завершении его испускания. Иначе говоря, сервис, испустивший сигнал, не ждет на него ответа, 
а сам сигнал является чисто информационным. Сигналы можно генерировать используя опцию \\- -no--wait утилиты initctl: \begin{verbatim}
initctl emit --no-wait <signal>
\end{verbatim} Неблокирующее поведение непосредственно влияет на доступность отправителя к дальнейшему взаимодействию без ожидания событий от других сервисов. Сервисы которые используют реакцию на события через директивы start on и stop on никак не могут приостановить работу сервисов, испускающих эти события.
\subsection*{Методы}
Методы представляют собой блокирующие или синхронные события, которые как правило используются совместно с заданиями (\textit{task}). Они работают подобно методам в языках программирования: вызывающий шлет событие 
и затем ждет реакцию на него в виде ответного события или кода завершения (успешного или нет).

Послать метод очень просто: \begin{verbatim}
initctl emit MyMethod
\end{verbatim} Это похоже на посылку сигнала за исключением того, что в данном случае событие обрабатывается синхронным образом, то есть пославший событие ждет, пока initctl завершит его обработку. По завершении работы initctl для задачи, которой был послан метод MyMethod. есть два способа выполнить работу: завершить ее успешно или вернуть код ошибки в систему. Минимальный файл конфигурации задачи, рассчитанной на запуск по приходу события MyMethod выглядит следующим образом: \\
\stanza{start on}{MyMethod} \\
\stanza{task} \\
\stanza{exec} \/usr/bin/myapp \$ACTION \\

Вы можете запустить задачу <jobname> и проверить результат ее выполнения следующей командой: \begin{verbatim}
initctl emit MyMethod ACTION=do_something
[ $? -ne 0 ] && { echo "ERROR: myapp failed"; exit 1; }
\end{verbatim} 
\subsection*{<<Ловушки>> (hooks)}
Событие-ловушка является синхронным. Иначе говоря, ловушка является чем-то средним между сигналом и методом: подобно сигналу она представляет собой уведомление об изменениях в системе, однако пославший <<ловушку>> ждет окончания ее обработки перед тем как отправить что-то ещё. <<Ловушки>> используются в качестве <<флагов>> для всех слушающих их сервисов. Примеры <<ловушек>> можно найти в справочных руководствах по событиям \event{starting} и \event{stopping}. 
\subsection*{События, а не состояния}
Хотя Upstart и использует внутренние состояния, которые могут быть выведены по команде status программы initctl,  но тем не менее обмен событиями является главным способом описать деятельность сервиса посредством условий \event{starting}, \event{started}, \event{stopping} и \event{stopped}. Эти события 
генерируются непосредственно перед изменениями состояний сервисов. Например, событие \event{starting} генерируется непосредственно перед тем как сервис становится в очередь на запуск.
\section{Жизненный цикл сервиса}
\subsection*{Запуск сервиса}
Рассмотрим для примера подробно весь процесс запуска некоторого сервиса.
\begin{enumerate}
\item Первоначально сервис находится в состоянии waiting --- оно отображается как stop/waiting в выводе команды initctl status.
\item Дается команда start, извещая сервис о необходимости запуска.
\item Состояние сервиса изменяется с waiting на starting.
\item Сервис отправляет событие \event{starting}, извещая систему о своей готовности стартовать.
\item Все сервисы, условия старта или остановки которых удовлетворяют этому событию, начинают запускаться или, соответственно, останавливаться.
\item Событие \event{starting} заканчивает обрабатываться.
\item Состояние сервиса меняется со starting на pre--start.
\item Если существует инструкция pre--start, то она исполняется.
\item Если секция pre--start исполняется с ошибками, то сервисом отправляются события \event{stopping} и 
\event{stopped}, а сам он начинает выполнять действия по завершению работы.
\item Иначе начинает запускаться главный процесс сервиса. 
\item Состояние сервиса изменяется с pre--start на spawned.
\item Если в файле конфигурации сервиса были использованы инструкции expect fork или \stanza{expect daemon}, то Upstart определяет окончательный PID процесса, исходя из наличия у него процесса--предка.
\item Состояние сервиса меняется на post--start, если такая секция существует в файле конфигурации сервиса, то она выполняется.
\item Состояние сервиса меняется на running, после этого он генерирует событие \event{started}. 
\item Все сервисы, настроенные на запуск или останов по этому событию, соответственно запускаются или останавливаются.
\end{enumerate}
\subsection*{Останов сервиса}
Теперь рассмотрим, что происходит при запросе сервиса на останов. \begin{enumerate}
\item Полностью рабочий сервис имеет цель start и состояние running, что отбражается как start/running в выводе команды initctl status.
\item Цель меняется со start на stop, извещая сервис о необходимости остановки.
\item Состояние меняется с running на pre--stop, соответственно выполняются все инструкции в секции pre--stop, если такая есть.
\item Состояние процесса меняется с pre--stop на stopping, после чего процесс отправляет сообщение stopping.

Сообщению stopping соответствуют несколько переменных окружения: \begin{itemize} 
\item JOB --- хранит в себе имя процесса сервиса; 
\item INSTANCE --- имя экземпляра сервиса, отправившего событие, если сервис выполняется в единственном числе, то эта переменная пуста; 
\item RESULT --- содержит строку <<ok>> или <<failed>> в зависимости от успеха процесса завершения сервиса; 
\item PROCESS --- содержит в себе имя секции, в которой произошел сбой, допустимые значения: pre--start, post--start, main (что означает инструкцию exec или script), pre--stop, post--stop, respawn (если исчерпан предел числа перезапусков сервиса); 
\item EXIT\_STATUS или EXIT\_SIGNAL, которые устанавливаются в зависимости от того завершился ли сервис самостоятельно (task) или был остановлен событием.  
\end{itemize}
\item Все сервисы, настроенные на запуск или останов по событию \event{stopping} от этого сервиса, запускаются или останавливаются.
\item Останавливается основной процесс сервиса, при этом: \begin{itemize}
\item Если была определена инструкция kill signal, то всем процессам, входящим в группу завершающегося сервиса, посылается определенный в ней сигнал.
\item Upstart дает время на завершение процесса сервиса, указанное в инструкции kill timeout --- по умолчанию 5 секунд. По умолчанию это сигнал SIGTERM.
\item Если процесс сервиса по истечении этого времени не завершится, то ему посылается сигнал SIGKILL, 
который не может быть проигнорирован. При этом завершается как сам главный процесс, так и вся группа принадлежащих ему процессов.
\end{itemize}
\item Состояние процесса изменяется с kill на post--stop, если в файле сервиса есть инструкция post--stop,
то исполняются относящиеся к ней команды.
\item Состояние сервиса изменяется с post--stop на waiting после чего посылается событие \event{stopped}, на которое остальные сервисы могут отреагировать. 
\end{enumerate}
\section{Порядок обработки событий}
\subsection{Порядок генерации событий}
Главное правило относительно генерации событий состоит в том, что этот порядок не предопределен. Ваша система является динамической и Upstart обрабатывает возникающие события <<как есть>>. Тем не менее, большинство систем, использующих Upstart, предоставляют некоторое количество заранее известных событий, которое вы можете обработать.

Предположим, у нас есть три сервиса: x, y, z со следующими файлами конфигурации: \begin{itemize}
\item \begin{verbatim}
/etc/init/x.conf
\end{verbatim}
\stanza{start on}{event-A}
\item \begin{verbatim}
/etc/init/y.conf
\end{verbatim}
\stanza{start on}{event-A}
\item \begin{verbatim}
/etc/init/z.conf
\end{verbatim}
\stanza{start on}{event-A}
\end{itemize}

Какой из этих трех сервисов стартует первым при генерации события \event{event-A}? Ответ: этого никогда нельзя знать заранее и никогда не следует ожидать какого-то определенного порядка запуска сервисов, имеющих одинаковые условия запуска. 
\subsection{Порядок обработки событий запуска и остановки}
Поясним его на примере сервиса odd: \begin{verbatim}
#/etc/init/odd.conf

start on event-a
stop on event-a

script 
	sleep 999
end script
\end{verbatim}
Допустимо ли такое с точки зрения Upstart? Да, допустимо. Дело в том, что Upstart всегда обрабатывает инструкцию stop on перед инструкцией start on. Таким образом, этот необычный сервис сначала остановится (если он выполнялся) перед тем как запуститься.

Рассмотрим теперь случай со многими сервисами, например, с двумя: \begin{verbatim}
#/etc/init/A.conf

start on startup
stop on foo

#/etc/init/B.conf

start on foo
\end{verbatim}

Если сервис A уже исполнялся, то генерация события foo сначала остановит сервис A и только потом запустит сервис B.
\section{Уровни исполнения}
Уровень исполнения (runlevel) представляет собой однобайтовое число обозначающее определенную конфигурацию работы ОС. В Debian и Ubuntu приняты следующие номера уровней: \begin{itemize}
\item 0 --- выключение системы.
\item 1 --- однопользовательский режим.
\item 2 --- многопользовательский режим с сетью и графикой (принят по умолчанию).

Режимы с номерами от 3 до 5 являются синонимами режима 2 и не используются.
\item 6 --- перезагрузка системы.

Кроме того, поддерживаются два псевдо-режима:
\item N --- предыдущий режим был неопределен.
\item S --- синоним однопользовательского режима.
\end{itemize}

Чтобы вывести сведения обо всех бывших активными режимах, следует выполнить команду runlevel от имени администратора системы, например: \begin{verbatim}
root@localhost# runlevel

N 2
\end{verbatim}
В данном случае вывод означает, что работа идет в графическом режиме и до него другие режимы не устанавливались. 

Для управления режимами системы используются утилиты shutdown, reboot и telinit.
\subsection{Смена режима работы по умолчанию}
Для изменения режима работы по умолчанию необходимо изменить значение переменной DEFAULT\_RUNLEVEL в файле \begin{verbatim*}
/etc/init/rc-sysinit.conf
\end{verbatim*}, либо же установить значение этой переменной как параметр ядра при загрузке системы (действует однократно).